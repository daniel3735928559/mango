
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mc/valuetype/lexer.go (66.7%)</option>
				
				<option value="file1">mc/valuetype/parser.go (61.3%)</option>
				
				<option value="file2">mc/valuetype/scanner.go (91.2%)</option>
				
				<option value="file3">mc/valuetype/valuetype.go (64.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package valuetype

import (
        "fmt"
)

type ValueTypeLexer struct {
        s *ValueTypeScanner
        lexerErrors *[]string
        result *ValueType
}

func (l *ValueTypeLexer) Lex(lval *ValueTypeParserSymType) int <span class="cov8" title="1">{
        tok, lit, pos := l.s.Scan()
        if tok == EOF </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">lval.token = Token{token: tok, literal: lit, position: pos}
        fmt.Println("Lexed",tok,lit,pos)
        return tok</span>
}

func (l *ValueTypeLexer) Error(e string) <span class="cov0" title="0">{
        le := *(l.lexerErrors)
        *(l.lexerErrors) = append(le, e)
        fmt.Println("ERROR",e)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">


package valuetype

import __yyfmt__ "fmt"


import (
        "errors"
        "fmt"
        value "mc/value"
        "strconv"
        "strings"
)

type Token struct {
        token    int
        literal  string
        position Position
}
type MapEntrySpec struct {
        Name       string
        Required   bool
        DefaultVal *value.Value
        ValType    *ValueType
}


type ValueTypeParserSymType struct {
        yys        int
        token      Token
        typedesc   *ValueType
        mapentries []*MapEntrySpec
        mapentry   *MapEntrySpec
        val        *value.Value
}

const IDENT = 57346
const NUMBER = 57347
const STRING = 57348
const TRUE = 57349
const FALSE = 57350
const NUM = 57351
const STR = 57352
const BOOL = 57353
const ONEOF = 57354

var ValueTypeParserToknames = [...]string{
        "$end",
        "error",
        "$unk",
        "IDENT",
        "NUMBER",
        "STRING",
        "TRUE",
        "FALSE",
        "NUM",
        "STR",
        "BOOL",
        "ONEOF",
        "'*'",
        "','",
        "'='",
        "'{'",
        "'}'",
        "'['",
        "']'",
        "'('",
        "')'",
        "':'",
}
var ValueTypeParserStatenames = [...]string{}

const ValueTypeParserEofCode = 1
const ValueTypeParserErrCode = 2
const ValueTypeParserInitialStackSize = 16



func Parse(exp string) (*ValueType, error) <span class="cov8" title="1">{
        l := new(ValueTypeLexer)
        lexerErrors := make([]string, 0)
        l.lexerErrors = &amp;lexerErrors
        l.s = new(ValueTypeScanner)
        l.s.Init(exp)
        //l.Init(strings.NewReader(exp))
        ValueTypeParserParse(l)
        if len(lexerErrors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New(strings.Join(lexerErrors, "\n"))
        }</span>
        <span class="cov8" title="1">return l.result, nil</span>
}


var ValueTypeParserExca = [...]int{
        -1, 1,
        1, -1,
        -2, 0,
}

const ValueTypeParserPrivate = 57344

const ValueTypeParserLast = 51

var ValueTypeParserAct = [...]int{

        36, 38, 39, 16, 2, 30, 31, 32, 33, 15,
        9, 20, 4, 3, 5, 7, 34, 41, 35, 8,
        19, 6, 21, 24, 25, 10, 42, 14, 40, 28,
        29, 11, 26, 17, 27, 46, 43, 22, 18, 37,
        13, 12, 1, 0, 44, 45, 0, 47, 0, 0,
        23,
}
var ValueTypeParserPact = [...]int{

        3, -1000, -1000, -1000, -1000, -1000, 3, 5, 36, 8,
        3, 16, 24, -2, -1000, 1, 23, -1000, 36, 3,
        2, -1000, 3, -1000, 19, 3, -1000, 0, -1000, -1000,
        -1000, -1000, -1000, -1000, 35, 0, 11, -5, 7, 22,
        -1000, 0, -1000, 0, 21, -1000, 35, -1000,
}
var ValueTypeParserPgo = [...]int{

        0, 42, 3, 9, 31, 41, 2, 1, 0,
}
var ValueTypeParserR1 = [...]int{

        0, 1, 2, 2, 2, 2, 2, 2, 3, 3,
        4, 4, 5, 5, 5, 6, 6, 6, 6, 6,
        6, 8, 8, 7, 7,
}
var ValueTypeParserR2 = [...]int{

        0, 1, 1, 1, 1, 3, 4, 3, 1, 3,
        1, 3, 3, 4, 5, 1, 1, 1, 1, 3,
        3, 3, 5, 1, 3,
}
var ValueTypeParserChk = [...]int{

        -1000, -1, -2, 10, 9, 11, 18, 12, 16, -2,
        20, -4, -5, 4, 19, -3, -2, 17, 14, 22,
        13, 21, 14, -4, -2, 22, -3, 15, -2, -6,
        5, 6, 7, 8, 16, 18, -8, 4, -7, -6,
        17, 22, 19, 14, -6, -7, 14, -8,
}
var ValueTypeParserDef = [...]int{

        0, -2, 1, 2, 3, 4, 0, 0, 0, 0,
        0, 0, 10, 0, 5, 0, 8, 7, 0, 0,
        0, 6, 0, 11, 12, 0, 9, 0, 13, 14,
        15, 16, 17, 18, 0, 0, 0, 0, 0, 23,
        19, 0, 20, 0, 21, 24, 0, 22,
}
var ValueTypeParserTok1 = [...]int{

        1, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        20, 21, 13, 3, 14, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 22, 3,
        3, 15, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 18, 3, 19, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
        3, 3, 3, 16, 3, 17,
}
var ValueTypeParserTok2 = [...]int{

        2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        12,
}
var ValueTypeParserTok3 = [...]int{
        0,
}

var ValueTypeParserErrorMessages = [...]struct {
        state int
        token int
        msg   string
}{}



/*        parser for yacc output        */

var (
        ValueTypeParserDebug        = 0
        ValueTypeParserErrorVerbose = false
)

type ValueTypeParserLexer interface {
        Lex(lval *ValueTypeParserSymType) int
        Error(s string)
}

type ValueTypeParserParser interface {
        Parse(ValueTypeParserLexer) int
        Lookahead() int
}

type ValueTypeParserParserImpl struct {
        lval  ValueTypeParserSymType
        stack [ValueTypeParserInitialStackSize]ValueTypeParserSymType
        char  int
}

func (p *ValueTypeParserParserImpl) Lookahead() int <span class="cov0" title="0">{
        return p.char
}</span>

func ValueTypeParserNewParser() ValueTypeParserParser <span class="cov8" title="1">{
        return &amp;ValueTypeParserParserImpl{}
}</span>

const ValueTypeParserFlag = -1000

func ValueTypeParserTokname(c int) string <span class="cov0" title="0">{
        if c &gt;= 1 &amp;&amp; c-1 &lt; len(ValueTypeParserToknames) </span><span class="cov0" title="0">{
                if ValueTypeParserToknames[c-1] != "" </span><span class="cov0" title="0">{
                        return ValueTypeParserToknames[c-1]
                }</span>
        }
        <span class="cov0" title="0">return __yyfmt__.Sprintf("tok-%v", c)</span>
}

func ValueTypeParserStatname(s int) string <span class="cov0" title="0">{
        if s &gt;= 0 &amp;&amp; s &lt; len(ValueTypeParserStatenames) </span><span class="cov0" title="0">{
                if ValueTypeParserStatenames[s] != "" </span><span class="cov0" title="0">{
                        return ValueTypeParserStatenames[s]
                }</span>
        }
        <span class="cov0" title="0">return __yyfmt__.Sprintf("state-%v", s)</span>
}

func ValueTypeParserErrorMessage(state, lookAhead int) string <span class="cov0" title="0">{
        const TOKSTART = 4

        if !ValueTypeParserErrorVerbose </span><span class="cov0" title="0">{
                return "syntax error"
        }</span>

        <span class="cov0" title="0">for _, e := range ValueTypeParserErrorMessages </span><span class="cov0" title="0">{
                if e.state == state &amp;&amp; e.token == lookAhead </span><span class="cov0" title="0">{
                        return "syntax error: " + e.msg
                }</span>
        }

        <span class="cov0" title="0">res := "syntax error: unexpected " + ValueTypeParserTokname(lookAhead)

        // To match Bison, suggest at most four expected tokens.
        expected := make([]int, 0, 4)

        // Look for shiftable tokens.
        base := ValueTypeParserPact[state]
        for tok := TOKSTART; tok-1 &lt; len(ValueTypeParserToknames); tok++ </span><span class="cov0" title="0">{
                if n := base + tok; n &gt;= 0 &amp;&amp; n &lt; ValueTypeParserLast &amp;&amp; ValueTypeParserChk[ValueTypeParserAct[n]] == tok </span><span class="cov0" title="0">{
                        if len(expected) == cap(expected) </span><span class="cov0" title="0">{
                                return res
                        }</span>
                        <span class="cov0" title="0">expected = append(expected, tok)</span>
                }
        }

        <span class="cov0" title="0">if ValueTypeParserDef[state] == -2 </span><span class="cov0" title="0">{
                i := 0
                for ValueTypeParserExca[i] != -1 || ValueTypeParserExca[i+1] != state </span><span class="cov0" title="0">{
                        i += 2
                }</span>

                // Look for tokens that we accept or reduce.
                <span class="cov0" title="0">for i += 2; ValueTypeParserExca[i] &gt;= 0; i += 2 </span><span class="cov0" title="0">{
                        tok := ValueTypeParserExca[i]
                        if tok &lt; TOKSTART || ValueTypeParserExca[i+1] == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if len(expected) == cap(expected) </span><span class="cov0" title="0">{
                                return res
                        }</span>
                        <span class="cov0" title="0">expected = append(expected, tok)</span>
                }

                // If the default action is to accept or reduce, give up.
                <span class="cov0" title="0">if ValueTypeParserExca[i+1] != 0 </span><span class="cov0" title="0">{
                        return res
                }</span>
        }

        <span class="cov0" title="0">for i, tok := range expected </span><span class="cov0" title="0">{
                if i == 0 </span><span class="cov0" title="0">{
                        res += ", expecting "
                }</span> else<span class="cov0" title="0"> {
                        res += " or "
                }</span>
                <span class="cov0" title="0">res += ValueTypeParserTokname(tok)</span>
        }
        <span class="cov0" title="0">return res</span>
}

func ValueTypeParserlex1(lex ValueTypeParserLexer, lval *ValueTypeParserSymType) (char, token int) <span class="cov8" title="1">{
        token = 0
        char = lex.Lex(lval)
        if char &lt;= 0 </span><span class="cov8" title="1">{
                token = ValueTypeParserTok1[0]
                goto out</span>
        }
        <span class="cov8" title="1">if char &lt; len(ValueTypeParserTok1) </span><span class="cov8" title="1">{
                token = ValueTypeParserTok1[char]
                goto out</span>
        }
        <span class="cov8" title="1">if char &gt;= ValueTypeParserPrivate </span><span class="cov8" title="1">{
                if char &lt; ValueTypeParserPrivate+len(ValueTypeParserTok2) </span><span class="cov8" title="1">{
                        token = ValueTypeParserTok2[char-ValueTypeParserPrivate]
                        goto out</span>
                }
        }
        <span class="cov0" title="0">for i := 0; i &lt; len(ValueTypeParserTok3); i += 2 </span><span class="cov0" title="0">{
                token = ValueTypeParserTok3[i+0]
                if token == char </span><span class="cov0" title="0">{
                        token = ValueTypeParserTok3[i+1]
                        goto out</span>
                }
        }

out:
        <span class="cov8" title="1">if token == 0 </span><span class="cov0" title="0">{
                token = ValueTypeParserTok2[1] /* unknown char */
        }</span>
        <span class="cov8" title="1">if ValueTypeParserDebug &gt;= 3 </span><span class="cov0" title="0">{
                __yyfmt__.Printf("lex %s(%d)\n", ValueTypeParserTokname(token), uint(char))
        }</span>
        <span class="cov8" title="1">return char, token</span>
}

func ValueTypeParserParse(ValueTypeParserlex ValueTypeParserLexer) int <span class="cov8" title="1">{
        return ValueTypeParserNewParser().Parse(ValueTypeParserlex)
}</span>

func (ValueTypeParserrcvr *ValueTypeParserParserImpl) Parse(ValueTypeParserlex ValueTypeParserLexer) int <span class="cov8" title="1">{
        var ValueTypeParsern int
        var ValueTypeParserVAL ValueTypeParserSymType
        var ValueTypeParserDollar []ValueTypeParserSymType
        _ = ValueTypeParserDollar // silence set and not used
        ValueTypeParserS := ValueTypeParserrcvr.stack[:]

        Nerrs := 0   /* number of errors */
        Errflag := 0 /* error recovery flag */
        ValueTypeParserstate := 0
        ValueTypeParserrcvr.char = -1
        ValueTypeParsertoken := -1 // ValueTypeParserrcvr.char translated into internal numbering
        defer func() </span><span class="cov8" title="1">{
                // Make sure we report no lookahead when not parsing.
                ValueTypeParserstate = -1
                ValueTypeParserrcvr.char = -1
                ValueTypeParsertoken = -1
        }</span>()
        <span class="cov8" title="1">ValueTypeParserp := -1
        goto ValueTypeParserstack</span>

ret0:
        <span class="cov8" title="1">return 0

</span>ret1:
        <span class="cov0" title="0">return 1

</span>ValueTypeParserstack:
        /* put a state and value onto the stack */
        <span class="cov8" title="1">if ValueTypeParserDebug &gt;= 4 </span><span class="cov0" title="0">{
                __yyfmt__.Printf("char %v in %v\n", ValueTypeParserTokname(ValueTypeParsertoken), ValueTypeParserStatname(ValueTypeParserstate))
        }</span>

        <span class="cov8" title="1">ValueTypeParserp++
        if ValueTypeParserp &gt;= len(ValueTypeParserS) </span><span class="cov8" title="1">{
                nyys := make([]ValueTypeParserSymType, len(ValueTypeParserS)*2)
                copy(nyys, ValueTypeParserS)
                ValueTypeParserS = nyys
        }</span>
        <span class="cov8" title="1">ValueTypeParserS[ValueTypeParserp] = ValueTypeParserVAL
        ValueTypeParserS[ValueTypeParserp].yys = ValueTypeParserstate

</span>ValueTypeParsernewstate:
        <span class="cov8" title="1">ValueTypeParsern = ValueTypeParserPact[ValueTypeParserstate]
        if ValueTypeParsern &lt;= ValueTypeParserFlag </span><span class="cov8" title="1">{
                goto ValueTypeParserdefault</span> /* simple state */
        }
        <span class="cov8" title="1">if ValueTypeParserrcvr.char &lt; 0 </span><span class="cov8" title="1">{
                ValueTypeParserrcvr.char, ValueTypeParsertoken = ValueTypeParserlex1(ValueTypeParserlex, &amp;ValueTypeParserrcvr.lval)
        }</span>
        <span class="cov8" title="1">ValueTypeParsern += ValueTypeParsertoken
        if ValueTypeParsern &lt; 0 || ValueTypeParsern &gt;= ValueTypeParserLast </span><span class="cov0" title="0">{
                goto ValueTypeParserdefault</span>
        }
        <span class="cov8" title="1">ValueTypeParsern = ValueTypeParserAct[ValueTypeParsern]
        if ValueTypeParserChk[ValueTypeParsern] == ValueTypeParsertoken </span><span class="cov8" title="1">{ /* valid shift */
                ValueTypeParserrcvr.char = -1
                ValueTypeParsertoken = -1
                ValueTypeParserVAL = ValueTypeParserrcvr.lval
                ValueTypeParserstate = ValueTypeParsern
                if Errflag &gt; 0 </span><span class="cov0" title="0">{
                        Errflag--
                }</span>
                <span class="cov8" title="1">goto ValueTypeParserstack</span>
        }

ValueTypeParserdefault:
        /* default state action */
        <span class="cov8" title="1">ValueTypeParsern = ValueTypeParserDef[ValueTypeParserstate]
        if ValueTypeParsern == -2 </span><span class="cov8" title="1">{
                if ValueTypeParserrcvr.char &lt; 0 </span><span class="cov8" title="1">{
                        ValueTypeParserrcvr.char, ValueTypeParsertoken = ValueTypeParserlex1(ValueTypeParserlex, &amp;ValueTypeParserrcvr.lval)
                }</span>

                /* look through exception table */
                <span class="cov8" title="1">xi := 0
                for </span><span class="cov8" title="1">{
                        if ValueTypeParserExca[xi+0] == -1 &amp;&amp; ValueTypeParserExca[xi+1] == ValueTypeParserstate </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">xi += 2</span>
                }
                <span class="cov8" title="1">for xi += 2; ; xi += 2 </span><span class="cov8" title="1">{
                        ValueTypeParsern = ValueTypeParserExca[xi+0]
                        if ValueTypeParsern &lt; 0 || ValueTypeParsern == ValueTypeParsertoken </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">ValueTypeParsern = ValueTypeParserExca[xi+1]
                if ValueTypeParsern &lt; 0 </span><span class="cov8" title="1">{
                        goto ret0</span>
                }
        }
        <span class="cov8" title="1">if ValueTypeParsern == 0 </span><span class="cov0" title="0">{
                /* error ... attempt to resume parsing */
                switch Errflag </span>{
                case 0:<span class="cov0" title="0"> /* brand new error */
                        ValueTypeParserlex.Error(ValueTypeParserErrorMessage(ValueTypeParserstate, ValueTypeParsertoken))
                        Nerrs++
                        if ValueTypeParserDebug &gt;= 1 </span><span class="cov0" title="0">{
                                __yyfmt__.Printf("%s", ValueTypeParserStatname(ValueTypeParserstate))
                                __yyfmt__.Printf(" saw %s\n", ValueTypeParserTokname(ValueTypeParsertoken))
                        }</span>
                        <span class="cov0" title="0">fallthrough</span>

                case 1, 2:<span class="cov0" title="0"> /* incompletely recovered error ... try again */
                        Errflag = 3

                        /* find a state where "error" is a legal shift action */
                        for ValueTypeParserp &gt;= 0 </span><span class="cov0" title="0">{
                                ValueTypeParsern = ValueTypeParserPact[ValueTypeParserS[ValueTypeParserp].yys] + ValueTypeParserErrCode
                                if ValueTypeParsern &gt;= 0 &amp;&amp; ValueTypeParsern &lt; ValueTypeParserLast </span><span class="cov0" title="0">{
                                        ValueTypeParserstate = ValueTypeParserAct[ValueTypeParsern] /* simulate a shift of "error" */
                                        if ValueTypeParserChk[ValueTypeParserstate] == ValueTypeParserErrCode </span><span class="cov0" title="0">{
                                                goto ValueTypeParserstack</span>
                                        }
                                }

                                /* the current p has no shift on "error", pop stack */
                                <span class="cov0" title="0">if ValueTypeParserDebug &gt;= 2 </span><span class="cov0" title="0">{
                                        __yyfmt__.Printf("error recovery pops state %d\n", ValueTypeParserS[ValueTypeParserp].yys)
                                }</span>
                                <span class="cov0" title="0">ValueTypeParserp--</span>
                        }
                        /* there is no state on the stack with an error shift ... abort */
                        <span class="cov0" title="0">goto ret1</span>

                case 3:<span class="cov0" title="0"> /* no shift yet; clobber input char */
                        if ValueTypeParserDebug &gt;= 2 </span><span class="cov0" title="0">{
                                __yyfmt__.Printf("error recovery discards %s\n", ValueTypeParserTokname(ValueTypeParsertoken))
                        }</span>
                        <span class="cov0" title="0">if ValueTypeParsertoken == ValueTypeParserEofCode </span><span class="cov0" title="0">{
                                goto ret1</span>
                        }
                        <span class="cov0" title="0">ValueTypeParserrcvr.char = -1
                        ValueTypeParsertoken = -1
                        goto ValueTypeParsernewstate</span> /* try again in the same state */
                }
        }

        /* reduction by production ValueTypeParsern */
        <span class="cov8" title="1">if ValueTypeParserDebug &gt;= 2 </span><span class="cov0" title="0">{
                __yyfmt__.Printf("reduce %v in:\n\t%v\n", ValueTypeParsern, ValueTypeParserStatname(ValueTypeParserstate))
        }</span>

        <span class="cov8" title="1">ValueTypeParsernt := ValueTypeParsern
        ValueTypeParserpt := ValueTypeParserp
        _ = ValueTypeParserpt // guard against "declared and not used"

        ValueTypeParserp -= ValueTypeParserR2[ValueTypeParsern]
        // ValueTypeParserp is now the index of $0. Perform the default action. Iff the
        // reduced production is ε, $1 is possibly out of range.
        if ValueTypeParserp+1 &gt;= len(ValueTypeParserS) </span><span class="cov0" title="0">{
                nyys := make([]ValueTypeParserSymType, len(ValueTypeParserS)*2)
                copy(nyys, ValueTypeParserS)
                ValueTypeParserS = nyys
        }</span>
        <span class="cov8" title="1">ValueTypeParserVAL = ValueTypeParserS[ValueTypeParserp+1]

        /* consult goto table to find next state */
        ValueTypeParsern = ValueTypeParserR1[ValueTypeParsern]
        ValueTypeParserg := ValueTypeParserPgo[ValueTypeParsern]
        ValueTypeParserj := ValueTypeParserg + ValueTypeParserS[ValueTypeParserp].yys + 1

        if ValueTypeParserj &gt;= ValueTypeParserLast </span><span class="cov8" title="1">{
                ValueTypeParserstate = ValueTypeParserAct[ValueTypeParserg]
        }</span> else<span class="cov8" title="1"> {
                ValueTypeParserstate = ValueTypeParserAct[ValueTypeParserj]
                if ValueTypeParserChk[ValueTypeParserstate] != -ValueTypeParsern </span><span class="cov8" title="1">{
                        ValueTypeParserstate = ValueTypeParserAct[ValueTypeParserg]
                }</span>
        }
        // dummy call; replaced with literal code
        <span class="cov8" title="1">switch ValueTypeParsernt </span>{

        case 1:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = nil
                        if l, ok := ValueTypeParserlex.(*ValueTypeLexer); ok </span><span class="cov8" title="1">{
                                l.result = ValueTypeParserDollar[1].typedesc
                        }</span>
                }
        case 2:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = MakeStringType()
                }</span>
        case 3:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = MakeNumType()
                }</span>
        case 4:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        ValueTypeParserVAL.typedesc = MakeBoolType()
                }</span>
        case 5:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = MakeListType(ValueTypeParserDollar[2].typedesc)
                }</span>
        case 6:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-4 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = ValueTypeParserDollar[3].typedesc
                }</span>
        case 7:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        map_defaults := make(map[string]*value.Value)
                        map_required := make(map[string]bool)
                        map_types := make(map[string]*ValueType)
                        for _, e := range ValueTypeParserDollar[2].mapentries </span><span class="cov8" title="1">{
                                map_required[e.Name] = e.Required
                                if e.DefaultVal != nil </span><span class="cov8" title="1">{
                                        map_defaults[e.Name] = e.DefaultVal
                                }</span>
                                <span class="cov8" title="1">map_types[e.Name] = e.ValType</span>
                        }
                        <span class="cov8" title="1">ValueTypeParserVAL.typedesc = &amp;ValueType{
                                Type:           TY_MAP,
                                MapArgTypes:    map_types,
                                MapArgRequired: map_required,
                                MapDefaults:    map_defaults}</span>
                }
        case 8:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = &amp;ValueType{
                                Type:       TY_ONEOF,
                                OneofTypes: []*ValueType{ValueTypeParserDollar[1].typedesc}}
                }</span>
        case 9:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.typedesc = &amp;ValueType{
                                Type:       TY_ONEOF,
                                OneofTypes: append([]*ValueType{ValueTypeParserDollar[1].typedesc}, ValueTypeParserDollar[3].typedesc.OneofTypes...)}
                }</span>
        case 10:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.mapentries = []*MapEntrySpec{ValueTypeParserDollar[1].mapentry}
                }</span>
        case 11:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.mapentries = append([]*MapEntrySpec{ValueTypeParserDollar[1].mapentry}, ValueTypeParserDollar[3].mapentries...)
                }</span>
        case 12:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        fmt.Println("sty", ValueTypeParserDollar[1].token.literal, ValueTypeParserDollar[3].typedesc)
                        ValueTypeParserVAL.mapentry = &amp;MapEntrySpec{
                                Name:       ValueTypeParserDollar[1].token.literal,
                                Required:   true,
                                DefaultVal: nil,
                                ValType:    ValueTypeParserDollar[3].typedesc}
                }</span>
        case 13:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-4 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.mapentry = &amp;MapEntrySpec{
                                Name:       ValueTypeParserDollar[1].token.literal,
                                Required:   false,
                                DefaultVal: nil,
                                ValType:    ValueTypeParserDollar[4].typedesc}

                }</span>
        case 14:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-5 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.mapentry = &amp;MapEntrySpec{
                                Name:       ValueTypeParserDollar[1].token.literal,
                                Required:   false,
                                DefaultVal: ValueTypeParserDollar[5].val,
                                ValType:    ValueTypeParserDollar[3].typedesc}
                }</span>
        case 15:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        x, _ := strconv.ParseFloat(ValueTypeParserDollar[1].token.literal, 64)
                        ValueTypeParserVAL.val = value.MakeFloatValue(x)
                }</span>
        case 16:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.val = &amp;value.Value{Type: value.VAL_STRING, StringVal: ValueTypeParserDollar[1].token.literal}
                }</span>
        case 17:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        ValueTypeParserVAL.val = value.MakeBoolValue(true)
                }</span>
        case 18:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        ValueTypeParserVAL.val = value.MakeBoolValue(false)
                }</span>
        case 19:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        ValueTypeParserVAL.val = ValueTypeParserDollar[2].val
                }</span>
        case 20:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.val = ValueTypeParserDollar[2].val
                }</span>
        case 21:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        ValueTypeParserVAL.val = &amp;value.Value{
                                Type:   value.VAL_MAP,
                                MapVal: map[string]*value.Value{ValueTypeParserDollar[1].token.literal: ValueTypeParserDollar[3].val}}
                }</span>
        case 22:<span class="cov0" title="0">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-5 : ValueTypeParserpt+1]

                </span><span class="cov0" title="0">{
                        map_val := ValueTypeParserDollar[5].val.MapVal
                        map_val[ValueTypeParserDollar[1].token.literal] = ValueTypeParserDollar[3].val
                        ValueTypeParserVAL.val = &amp;value.Value{
                                Type:   value.VAL_MAP,
                                MapVal: map_val}
                }</span>
        case 23:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-1 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.val = &amp;value.Value{
                                Type:    value.VAL_LIST,
                                ListVal: []*value.Value{ValueTypeParserDollar[1].val}}
                }</span>
        case 24:<span class="cov8" title="1">
                ValueTypeParserDollar = ValueTypeParserS[ValueTypeParserpt-3 : ValueTypeParserpt+1]

                </span><span class="cov8" title="1">{
                        ValueTypeParserVAL.val = &amp;value.Value{
                                Type:    value.VAL_LIST,
                                ListVal: append([]*value.Value{ValueTypeParserDollar[1].val}, ValueTypeParserDollar[3].val.ListVal...)}
                }</span>
        }
        <span class="cov8" title="1">goto ValueTypeParserstack</span> /* stack new state and value */
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package valuetype

import (
        "fmt"
)

const (
        EOF     = -1
        UNKNOWN = 0
)

var (
        keywords = map[string]int{"string":STR, "num":NUM, "bool": BOOL, "true": TRUE, "false": FALSE, "oneof": ONEOF}
        charsyms = map[rune]int {
                '=':'=',
                ',':',',
                '{':'{',
                '}':'}',
                '[':'[',
                ']':']',
                '(':'(',
                ')':')',
                ';':';',
                ':':':',
                '*':'*'}
)

type Position struct {
        Line   int
        Column int
}

type ValueTypeScanner struct {
        src      []rune
        offset   int
        lineHead int
        line     int
}

func (s *ValueTypeScanner) Init(src string) <span class="cov8" title="1">{
        s.src = []rune(src)
}</span>

func (s *ValueTypeScanner) Scan() (tok int, lit string, pos Position) <span class="cov8" title="1">{
        s.skipWhiteSpace()
        pos = s.position()
        switch ch := s.peek(); </span>{
        case isLetter(ch):<span class="cov8" title="1">
                lit = s.scanIdentifier()
                fmt.Println("scanning kwds",lit)
                if keyword, ok := keywords[lit]; ok </span><span class="cov8" title="1">{
                        tok = keyword
                }</span> else<span class="cov8" title="1"> {
                        tok = IDENT
                }</span>
        case isDigit(ch):<span class="cov8" title="1">
                tok, lit = NUMBER, s.scanNumber()</span>
        case ch == '"':<span class="cov8" title="1">
                tok, lit = STRING, s.scanString()</span>
                //fmt.Println("STRING",lit)
        default:<span class="cov8" title="1">
                tok, lit = s.scanSym()</span>
        }
        <span class="cov8" title="1">return</span>
}

// ========================================

func isLetter(ch rune) bool <span class="cov8" title="1">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' || ch == '_'
}</span>

func isDigit(ch rune) bool <span class="cov8" title="1">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9'
}</span>

func isWhiteSpace(ch rune) bool <span class="cov8" title="1">{
        return ch == ' ' || ch == '\t' || ch == '\n'
}</span>

func (s *ValueTypeScanner) peek() rune <span class="cov8" title="1">{
        if !s.reachEOF() </span><span class="cov8" title="1">{
                return s.src[s.offset]
        }</span> else<span class="cov8" title="1"> {
                return -1
        }</span>
}

func (s *ValueTypeScanner) next() <span class="cov8" title="1">{
        if !s.reachEOF() </span><span class="cov8" title="1">{
                if s.peek() == '\n' </span><span class="cov0" title="0">{
                        s.lineHead = s.offset + 1
                        s.line++
                }</span>
                <span class="cov8" title="1">s.offset++</span>
        }
}

func (s *ValueTypeScanner) reachEOF() bool <span class="cov8" title="1">{
        return len(s.src) &lt;= s.offset
}</span>

func (s *ValueTypeScanner) position() Position <span class="cov8" title="1">{
        return Position{Line: s.line + 1, Column: s.offset - s.lineHead + 1}
}</span>

func (s *ValueTypeScanner) skipWhiteSpace() <span class="cov8" title="1">{
        for isWhiteSpace(s.peek()) </span><span class="cov0" title="0">{
                s.next()
        }</span>
}

func (s *ValueTypeScanner) scanIdentifier() string <span class="cov8" title="1">{
        var ret []rune
        for isLetter(s.peek()) || isDigit(s.peek()) </span><span class="cov8" title="1">{
                ret = append(ret, s.peek())
                s.next()
        }</span>
        <span class="cov8" title="1">return string(ret)</span>
}


func (s *ValueTypeScanner) scanSym() (int, string) <span class="cov8" title="1">{
        fc := s.peek()
        if fc == -1 </span><span class="cov8" title="1">{
                return EOF, ""
        }</span> else<span class="cov8" title="1"> if tok, ok := charsyms[fc]; ok </span><span class="cov8" title="1">{
                s.next()
                lit := string(fc)
                return tok, lit
        }</span>
        <span class="cov0" title="0">return -1, "error"</span>
}

func (s *ValueTypeScanner) scanNumber() string <span class="cov8" title="1">{
        var ret []rune
        hasDecimal := false
        for isDigit(s.peek()) || (s.peek() == '.' &amp;&amp; !hasDecimal) </span><span class="cov8" title="1">{
                ret = append(ret, s.peek())
                if s.peek() == '.' </span><span class="cov0" title="0">{
                        hasDecimal = true
                }</span>
                <span class="cov8" title="1">s.next()</span>
        }
        <span class="cov8" title="1">fmt.Println("SN",string(ret))
        return string(ret)</span>
}

func (s *ValueTypeScanner) scanString() string <span class="cov8" title="1">{
        var ret []rune
        s.next()
        for s.peek() != '"' || (len(ret) &gt; 0 &amp;&amp; ret[len(ret)-1] == '\\') </span><span class="cov8" title="1">{
                ret = append(ret, s.peek())
                s.next()
        }</span>
        <span class="cov8" title="1">s.next()
        return string(ret)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package valuetype

import (
        "fmt"
        "sort"
        "strings"
        value "mc/value"
)


type ValueTypeKind int

const (
        TY_ONEOF ValueTypeKind = iota + 1
        TY_MAP
        TY_LIST
        TY_NUM
        TY_STRING
        TY_BOOL
        TY_EXT
)

var (
        ValueTypeMapping = map[ValueTypeKind]value.ValueKind{
                TY_ONEOF: value.VAL_ANY,
                TY_MAP: value.VAL_MAP,
                TY_LIST: value.VAL_LIST,
                TY_NUM: value.VAL_NUM,
                TY_STRING: value.VAL_STRING,
                TY_BOOL: value.VAL_BOOL}
)

type ValueType struct {
        Name string
        Type ValueTypeKind
        ExternalTypeName string
        MapArgTypes map[string]*ValueType
        MapArgRequired map[string]bool
        MapDefaults map[string]*value.Value
        ListArgType *ValueType
        OneofTypes []*ValueType
}

func (ty *ValueType) ToString() string <span class="cov8" title="1">{
        if ty.Type == TY_ONEOF </span><span class="cov8" title="1">{
                subtypes := make([]string, len(ty.OneofTypes))
                for i, sty := range ty.OneofTypes </span><span class="cov8" title="1">{
                        subtypes[i] = sty.ToString()
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("oneof(%s)", strings.Join(subtypes, ","))</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_MAP </span><span class="cov8" title="1">{
                keys := make([]string, 0)
                for k, _ := range ty.MapArgTypes </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)
                entries := make([]string, 0)
                // Check if all the keys in v are expected
                for _, k := range keys </span><span class="cov8" title="1">{
                        sty := ty.MapArgTypes[k]
                        req := "*"
                        if ty.MapArgRequired[k] </span><span class="cov8" title="1">{
                                req = ""
                        }</span>
                        <span class="cov8" title="1">def := ""
                        if defaultval, ok := ty.MapDefaults[k]; ok </span><span class="cov8" title="1">{
                                def = "="+defaultval.ToString()
                                req = ""
                        }</span>
                        <span class="cov8" title="1">entries = append(entries, fmt.Sprintf("%s%s:%s%s", k, req, sty.ToString(), def))</span>
                }
                <span class="cov8" title="1">return fmt.Sprintf("{%s}", strings.Join(entries, ","))</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_LIST </span><span class="cov8" title="1">{
                return fmt.Sprintf("[%s]", ty.ListArgType.ToString())
        }</span> else<span class="cov8" title="1"> if ty.Type == TY_NUM </span><span class="cov8" title="1">{
                return "num"
        }</span> else<span class="cov8" title="1"> if ty.Type == TY_STRING </span><span class="cov8" title="1">{
                return "string"
        }</span> else<span class="cov0" title="0"> if ty.Type == TY_BOOL </span><span class="cov0" title="0">{
                return "bool"
        }</span> else<span class="cov0" title="0"> if ty.Type == TY_EXT </span><span class="cov0" title="0">{
                return ty.ExternalTypeName
        }</span>
        <span class="cov0" title="0">return "[unknown]"</span>
}

func MakeExtType(name string) *ValueType <span class="cov0" title="0">{
        return &amp;ValueType{Type: TY_EXT, ExternalTypeName: name}
}</span>
func MakeBoolType() *ValueType <span class="cov0" title="0">{
        return &amp;ValueType{Type: TY_BOOL}
}</span>
func MakeNumType() *ValueType <span class="cov8" title="1">{
        return &amp;ValueType{Type: TY_NUM}
}</span>
func MakeStringType() *ValueType <span class="cov8" title="1">{
        return &amp;ValueType{Type: TY_STRING}
}</span>
func MakeListType(subtype *ValueType) *ValueType <span class="cov8" title="1">{
        return &amp;ValueType{
                Type: TY_LIST,
                ListArgType: subtype}
}</span>
func MakeOneofType(subtypes []*ValueType) *ValueType <span class="cov0" title="0">{
        return &amp;ValueType{
                Type: TY_ONEOF,
                OneofTypes: subtypes}
}</span>

// Get the value types possibly conforming to ty
func (ty *ValueType) PossibleValueTypes() []value.ValueKind <span class="cov0" title="0">{
        possible := map[value.ValueKind]bool{
                value.VAL_MAP:false,
                value.VAL_LIST:false,
                value.VAL_NAME:false,
                value.VAL_NUM:false,
                value.VAL_STRING:false,
                value.VAL_BOOL:false}
        if ty.Type == TY_ONEOF </span><span class="cov0" title="0">{
                ans := []value.ValueKind{}
                for _, sty := range ty.OneofTypes </span><span class="cov0" title="0">{
                        for _, tyty := range sty.PossibleValueTypes() </span><span class="cov0" title="0">{
                                if !possible[tyty] </span><span class="cov0" title="0">{
                                        possible[tyty] = true
                                        ans = append(ans, tyty)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return ans</span>
        }
        <span class="cov0" title="0">return []value.ValueKind{ValueTypeMapping[ty.Type]}</span>
}

// Does v conform to ty?
func (ty *ValueType) Validate(v *value.Value, ext_types map[string]*ValueType, path string) (*value.Value, error) <span class="cov8" title="1">{
        fmt.Println("Validate",ty,v)
        if ty.Type == TY_ONEOF </span><span class="cov8" title="1">{
                for _, sty := range ty.OneofTypes </span><span class="cov8" title="1">{
                        if sv, err := sty.Validate(v, ext_types, path); err == nil </span><span class="cov8" title="1">{
                                return sv, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, fmt.Errorf("Error at %s: Subvalue does not validate as any of the given types", path)</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_MAP &amp;&amp; v.Type == value.VAL_MAP </span><span class="cov8" title="1">{
                fmt.Println("map")
                // Check if all the keys in v are expected
                for k, _ := range v.MapVal </span><span class="cov8" title="1">{
                        if _, ok := ty.MapArgTypes[k]; !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error at %s: Unexpected map entry: %s", path, k)
                        }</span>
                }
                // Check all required keys are present
                <span class="cov8" title="1">for k, r := range ty.MapArgRequired </span><span class="cov8" title="1">{
                        if _, ok := v.MapVal[k]; r &amp;&amp; !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error at %s: Map entry `%s` required", path, k)
                        }</span>
                }
                // Populate default values of absent values
                <span class="cov8" title="1">for k, defval := range ty.MapDefaults </span><span class="cov8" title="1">{
                        if _, ok := v.MapVal[k]; !ok </span><span class="cov8" title="1">{
                                v.MapVal[k] = defval
                        }</span>
                }
                // Now check each is of the required type
                <span class="cov8" title="1">for k, sv := range v.MapVal </span><span class="cov8" title="1">{
                        svv, err := ty.MapArgTypes[k].Validate(sv, ext_types, fmt.Sprintf("%s.%s",path,k))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error at %s: %v", path, err)
                        }</span> else<span class="cov8" title="1"> {
                                v.MapVal[k] = svv
                        }</span>
                }
                <span class="cov8" title="1">return v, nil</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_LIST &amp;&amp; v.Type == value.VAL_LIST </span><span class="cov8" title="1">{
                for i, sv := range v.ListVal </span><span class="cov8" title="1">{
                        svv, err := ty.ListArgType.Validate(sv, ext_types, fmt.Sprintf("%s[%d]", path, i))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("Error at %s: %v", path, err)
                        }</span> else<span class="cov8" title="1"> {
                                v.ListVal[i] = svv
                        }</span>
                }
                <span class="cov8" title="1">return v, nil</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_NUM </span><span class="cov8" title="1">{
                if v.Type == value.VAL_NUM </span><span class="cov8" title="1">{
                        return v, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("Error at %s: num expected", path)</span>
        } else<span class="cov8" title="1"> if ty.Type == TY_STRING </span><span class="cov8" title="1">{
                if v.Type == value.VAL_STRING </span><span class="cov8" title="1">{
                        return v, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("Error at %s: string expected", path)</span>
        } else<span class="cov0" title="0"> if ty.Type == TY_BOOL </span><span class="cov0" title="0">{
                if v.Type == value.VAL_BOOL </span><span class="cov0" title="0">{
                        return v, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("Error at %s: bool expected", path)</span>
        } else<span class="cov0" title="0"> if ty.Type == TY_EXT </span><span class="cov0" title="0">{
                if et, ok := ext_types[ty.ExternalTypeName]; ok </span><span class="cov0" title="0">{
                        return et.Validate(v, ext_types, path)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("Error at %s: Unknown type `%s`", path, ty.ExternalTypeName)</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("Invalid type: %s", path)</span>
}

</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
